#ifndef __FILE_LIST_H__
#define __FILE_LIST_H__

#include <stdint.h>
#include <stdlib.h>
#include <dirent.h>
#include "bool.h"
#include "err_msg.h"
#include "err_hand.h"
#include "path_utils.h"

typedef struct _filelist__def                       // <----- DEFINE FileList
{
    int num_items;                                  // Count the number of files and folders
    int num_files;                                  // Count the number of files only
    int num_folders;                                // Count the number of folders only
    char **names;                                   // List of file names
    char **first_name;                              // Remember first address in this list
    int _idx;                                       // Index file number (used by _next and _prev)
} FileList;

bool _filelist__is_ignore(char *str)
{
    /* *************DOC***************
     * Ignore any file starting with '.'
     * TODO: ignore any file that does not END with ".bmp" or ".gif"
     * *******************************/
    return (str[0] == '.') ? true : false;
}
int _filelist__validate_dir(const char *path)
{
    /* *************DOC***************
     * const char *path : path (relative to this folder)
     * return -1 if there is an error (e.g., if path does not exist)
     * return 0 on success
     *
     * This function handles printing an error message if
     * the path does not exist.
     *
     * The error message is generated by the error handler
     * "ErrHand_quit_if_cannot_open(dir)".
     * *******************************/
    DIR *dir = opendir(path);
    ErrHand_quit_if_cannot_open(dir);       // Return -1 on fail (e.g., path does not exist)
    closedir(dir); return 0;
}
int _filelist__itemcount(const char *path)
{
    /* *************DOC***************
     * const char *path : path (relative to this folder)
     * return -1 if there is an error (e.g., if path does not exist)
     * return number of items on success
     *      - "items" are files and folders
     *      - "." and ".." are not counted
     * *******************************/
    int fcount = 0;                                     // Count files and folders
    if (_filelist__validate_dir(path) < 0) return -1;    // Validate directory
    DIR *dir = opendir(path);
    struct dirent *entry;
    while (  (entry = readdir(dir))  )
    {
        // Ignore . and ..
        if (!_filelist__is_ignore(entry->d_name)) fcount++;
    }
    closedir(dir);
    return fcount;
}

/* *************API***************
 * Use the functions below to work with the FileList type.
 * *******************************/

int FileList_filecount(FileList *fList)
{ // Return number of files
    int filecount = 0;
    for (int i=0; i<fList->num_items; i++) {if(  !PathUtils_is_dir(fList->names[i])  ) filecount++;}
    return filecount;
}
int FileList_foldercount(FileList *fList)
{ // Return number of folders
    int foldercount = 0;
    for (int i=0; i<fList->num_items; i++) {if(  PathUtils_is_dir(fList->names[i])  ) foldercount++;}
    return foldercount;
}
const char* FileList_next(FileList *fList)
{ // Return name of next file
    /* *************DOC***************
     * Return the name of the next file.
     * If this is the last file, wrap back to the first name.
     * *******************************/
    fList->_idx++;
    if (fList->_idx >= fList->num_items) fList->_idx=0;     // Wrap-around
    return fList->names[fList->_idx];
}
const char* FileList_prev(FileList *fList)
{ // Return name of previous file
    /* *************DOC***************
     * Return the name of the previous file.
     * If this is the first file, wrap back to the last name.
     * *******************************/
    fList->_idx--;
    if (fList->_idx < 0) fList->_idx=fList->num_items-1;    // Wrap-around
    return fList->names[fList->_idx];
}

/* *************NEW and FREE***************
 * FileList create and destroy.
 * *******************************/
FileList* FileList_new_from_path(const char *path)              // <----- NEW FileList
{
    /* *************DOC***************
     * Create a FileList.
     *
     * Example
     * -------
     *  #include "file_list.h"
     *  ...
     *      FileList* fList = FileList_new_from_path("my_path");
     *      ... // use fList
     *      FileList_free(fList);
     *
     * This is a list of the files and folders found in
     * "path". The "path" must be a folder.
     *
     * The names in the file list are the full path:
     *
     *      File "a.bmp" in path "img/" is recorded as "img/a.bmp"
     *
     * const char *path : folder path relative to the .exe
     * return FileList* on success
     * return NULL if there is an error
     *
     * Caller must free FileList. It is safe but unnecessary
     * to call FileList_free on a NULL pointer.
     * *******************************/
    /* *************Error Handling***************
     * An error message is printed to stderr if `path`
     * cannot be opened. There is nothing for the caller to
     * "cleanup".
     *
     * Example
     * -------
     *  #include "file_list.h"
     *  ...
     *      fflush(stdout);                                 // Flush any pending output
     *      const char *bad = "bad";                        // Non-existent folder
     *      FileList *bList = FileList_new_from_path(bad);  // Try making a FileList
     *      if (bList == NULL) return EXIT_FAILURE;         // Bad list is NULL. Exit program.
     * 
     * The above code produces this error message:
     *
     *
     * > file_list.h: In function _filelist__validate_dir():
     * >         Cannot open dir "bad": No such file or directory
     *
     * I exit the program in this example, but of course
     * it is also OK to continue program execution.
     * *******************************/
    if (  _filelist__validate_dir(path) < 0  ) return NULL; // Validate directory
    FileList *fList = malloc(sizeof(*fList));

    fList->num_items = _filelist__itemcount(path);          // _filelist__itemcount() handles any opendir error
    /* if(fList->num_items < 0) {free(fList); return NULL;}        // Return if there was an error */
    fList->names = malloc(sizeof(char **)*(fList->num_items));  // Allocate mem for pointers to each file name
    fList->first_name = fList->names;                           // Remember address of first name

    // Make the list of file names.

    // Count number of characters in path e.g., len("img")
    int len_path = 0; {const char *c = path; while ( (*c++!='\0') ) len_path++;}

    DIR *dir = opendir(path);
    struct dirent *entry;

    while (  (entry = readdir(dir))  )
    {
        if (!_filelist__is_ignore(entry->d_name))
        {
            // +1 : slash (path separator)
            // +1 : dirent::d_namlen does not include '\0' nul terminator
            // ---> DO NOT USE entry->d_namlen <---
            //      Some msys installs do not have d_namlen in their dirent struct.
            // Count number of characters in file name
            int len_name = 0; {const char *c = entry->d_name; while ( (*c++!='\0') ) len_name++;}
            int len_full_path = len_path + 1 + len_name + 1;
            char *name = malloc(sizeof(char)*(len_full_path));          // Allocate mem for this name
            const char *s = path; char *d = name;                       // s : src ptr , d : dest ptr
            while( (*s != '\0') ) *d++ = *s++;                          // Copy the folder path
            *d++ = '/';                                                 // path separator
            s = entry->d_name;
            while( (*s != '\0') ) *d++ = *s++;                          // Copy the file name
            *d = '\0';                                                  // nul-terminate this string
            *fList->names++ = name;

            // RECURSE
            /* if PathUtils_is_dir(name) fList->FileLists++ = FileList_new_from_path(name); */
            // No, don't make FileList a recursive structure.
            // If this is a directory, enter it and continue adding to names
            /* if PathUtils_is_dir(name) */
            /* { */
            /* } */
        }
    }
    fList->names = fList->first_name;                               // Rewind list of names
    fList->_idx = 0;                                                // Start "next" name at index 0
    closedir(dir);
    // Pass the names to sys/stat to count the number of files and folders.
    fList->num_files = FileList_filecount(fList);
    fList->num_folders = FileList_foldercount(fList);
    return fList;
}
void FileList_free(FileList *fList)                         // <----- DESTROY FileList
{
    /* *************DOC***************
     * Free all memory allocated for the FileList.
     *
     * It is safe (but unnecessary) to call FileList_free()
     * on a NULL pointer.
     *
     * It is up to the caller whether to set fList to NULL.
     *
     * Example
     * -------
     *      FileList_free(fList); fList = NULL;
     * *******************************/
    if (fList==NULL) return;
    // Free the list of file names
    for (int i=0; i<fList->num_items; i++)
    {
        free(fList->names[i]);                              // Free each name
        fList->names[i] = NULL;
    }
    free(fList->names);                                     // Free the list of names
    fList->names = NULL;
}

#endif // __FILE_LIST_H__
